# EPT - Extended ProtoThreads

EPT - это небольшое расширение над классическими [протопотоками](https://dunkels.com/adam/pt/index.html).

## Использование
EPT представляет собой STB-библиотеку из одного заголовочного файла. Для использования EPT необходимо включить этот файл в проект и в одном месте определить частоту вызова системного таймера через макрос `EPT_TICK_FREQ_HZ`. Также необходимо поместить в обработчик прерывания системного таймера вызов функции `etp_tick()`.

## Расширения

### Таймеры
Каждый EPT-поток теперь оснащен таймером, позволяющим упростить реализацию не-блокирующего ожидания потока (новый макрос `EPT_SLEEP(ept, time_ms)`)

### События
У каждого EPT-потока есть флаг события, который может быть установлен извне для управления исполнением потока. Для того, чтобы воспользоваться этим функционалом протопоток должен быть организован следующим образом:
```c
PT_THREAD(ept_thread(struct ept* ept))
{
  PT_BEGIN(ept);
  while(1)
  {
    while(!ept->event)
    { 
    //Основное тело потока располагается здесь
    }
    { 
    //Обработчик внешних событий располагается здесь.
    //После обработки ept->event должен быть сброшен 
      ept->event = 0;
      return PT_YIELDED; 
    }
  }
  PT_END(ept);
}
```
### Контекст
Каждый EPT-поток может хранить указатель на некий заранее описанный контекст потока. Протопотоки не допускают использование локальных переменных, и в большинстве случаем достаточно использования глобальных статичных переменных. Однако, если требуется запустить два одинаковых потока, каждый из них может иметь свой собственный контекст выполнения. Для того, чтобы это реализовать контекст должен быть создан вне протопотока, а полю ctx структуры ept-потока должен быть присвоен адрес экземпляра контекста (в примере ниже это структура `thread_context_t context`). 
В самом протопотоке необходимо создать указатель на контекст потока и явно привести указатель ept->ctx к этому типу. Эту операцию необходимо расположить перед инструкцией `PT_BEGIN(ept);`
```c

typedef struct
{
    uint8_t a;
    uint16_t b;
} thread_context_t;

thread_context_t context;
struct ept ept = {.ctx = &context};

PT_THREAD(periodic_writer(struct ept* ept))
{
  thread_context_t* ctx = (thread_context_t*) ept->ctx;
  PT_BEGIN(ept);
  while(1)
  {
    //Основное тело потока располагается здесь
  }
  PT_END(ept)
}
```
### Управление состоянием
Для вызова протопотоков появился макрос `EPT_SPIN`. Он обеспечивает возможность управления исполнением EPT-потоков (например, через командный интерфейс). Этот макрос переходит в функцию потока в зависимости от значения поля `ept->state`.
Доступ к существующим структурам ept-потоков можно получить, например, создав массив из указателей на все существующие ept-потоки. Далее из этого массива возможно выбрать интересующий поток по уникальному имени, которое хранится в поле `ept->name`. Уникальность имени должен обеспечить программист.
```c

struct ept ept1 = {.name = "EPT1"};
struct ept ept2 = {.name = "EPT2"};

struct ept all_ept_threads[] = {&ept1, &ept2};

void main()
{
    EPT_INIT(&ept1);
    EPT_INIT(&ept2);
    while(1)
    {
        EPT_SPIN(&ept1, ept_thread2(&ept1));
        EPT_SPIN(&ept2, ept_thread2(&ept2));
    }
}
```